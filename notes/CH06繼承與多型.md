## 閱讀書籍
- Java SE 17技術手冊－林信良

***
## 重點摘要
### 繼承
- 減少了重複的程式片段
- 多型的實踐
- 延伸閱讀：[上下轉型](https://hackmd.io/@Rainmeo/Upcasting_And_Downcasting)

### @Override：重新定義
- 可以造成差異化（同個家庭的兄弟姊妹，做同一件事情的方法不一定都要一樣）
- 重新定義的方法，修飾子範圍只能更大，不能更小（像是public變private是不行的）

### abstract：抽象
- 雖然可以透過`@Override`擴充／改寫繼承自父類別的方法，但並沒有強制力，如果在類跟方法上頭加上`abstract`的字樣，可以請使用者強制重新定義(`@Override`)
- 抽象類不能被建立為實體
- 抽象類也能寫一班方法
- 繼承自抽象類若不實作，只能繼續抽象（單繼承）

#### 略提「介面」
- 多實作
- 預設全是抽象方法（只是沒寫出來）
- 一般情況也無法實例化，但匿名方法可以（同時得覆寫抽象方法～）

### protected
- 讓子類別或同package可以存取屬性的一種修飾子

### default
- 讓同package可以存取屬性的一種修飾子

### super
- 取得父類別方法
- 父類別欲使用的方法不可以有private修飾子

### 建構子
- 若有繼承關係，會先執行父類別的建構子（沒指定`super(傳入)`就是找空參數建構子，那如果父類沒有，就報錯囉！），再執行子類的建構子
- this跟super只能擇一，而且都只能在建構子第一行

### final
- 加在`class`上，該類不可以再被繼承！
- 加在`method`上，該方法不能再被`@Override`

### Object API
- 什麼都能裝的陣列
```java
//什麼都能裝的陣列誕生了
Object[] bag = {"apple", 1, 1.05};
```
但不太好用就是了

- Object包括的東西：`toString`、`equals`、`hashCode`

#### instanceOf：檢查是否為建構子
- 不得不說這段有點難耶...

### GC：垃圾收集
- 執行緒結束後觸發？！
